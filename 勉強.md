__Go自習なう__
- bin:アプリケーションの実行可能ファイルを含めます。
- src:ワークステーションに存在するすべてのアプリケーションのソース コードを含めます。
- pkg:使用可能なライブラリのコンパイル済みバージョンを含めます。 再コンパイルせずに、コンパイラから、これらのライブラリにリンクできます
- 実行可能ファイルがほしいときは`go build (作りたいファイル名).go`で作れる
- 変数の宣言をするときは`var (変数名) (型)`で宣言する
- 他の言語と同様に、コンマで区切ると複数の変数を宣言できる
- 変数の宣言と同時に初期化することもできる
- `var (firstName, lastName, age = "John", "Doe", 32)`のように宣言可能。または`firstName, lastName := "John", "Doe" age := 32`のように`:=`を使って宣言可能
- 変数の型を省略することもできる。`var (firstName, lastName, age = "John", "Doe", 32)`のように宣言すると、Goは自動的に型を推測する
- `:=`を使って宣言すると、Goは自動的に型を推測する
- constを使って定数を宣言することもできる  
`const httpStatusOK = 200`など
~~~
const (
    StatusOK              = 0
    StatusConnectionReset = 1
    StatusOtherError      = 2
)
~~~
↑のように、複数の定数を宣言するときは、constを使ってブロックを作ることができる

- String型から文字を取得しようとすると、文字のバイト値が返されてしまう。これを回避するには __rune型__ を使う必要がある。
rune型の例は以下の通り
~~~
str1 := "文字列"
r1 := []rune(str1)  // rune型の配列 ( 1文字ずつ文字を保持 )
fmt.Println(r1[0])  // 出力：25991 ( 1文字目のUnicodeのコードポイント )
fmt.Println(string(r1[0])) // 出力：文 ( rune型はUnicodeのコードポイントなので、string型に戻すと正しく1文字を表示できる )
~~~

- __使っていない変数やimportがあると、エラーが発生する__
- __戻り値の関係で使用しない変数は、_にすることでエラーを回避できる__
コード例
~~~
plusAndMinus := func(num1 int, num2 int) (int, int) {
	return num1 + num2, num1 - num2
}
_, result2 := plusAndMinus(8, 7) // エラーが出ない （変数「_ ( アンダースコア ) 」は使わない変数として扱われる
fmt.Println(result2)
~~~

